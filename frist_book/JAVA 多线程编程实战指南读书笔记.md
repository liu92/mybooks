## JAVA 多线程编程实战指南读书笔记

#### 1、`` 什么是多线程编程？``

  多线程编程就是以线程为基本抽象单位的一种编程范式。

#### 2、`` 为什么使用多线程编程？``

  比如 我们在使用手机的时候，我们希望在听歌的时候可以看一些其他的文章，那么这个时候如果是单线程的话 我们就只能 听歌，而不能使用其他的app看 文章这些，这样比较麻烦。而使用了多线程后 我们就可以多个操作都可以进行。

#### 3、``线程的创建、启动和运行``

   在java平台中创建一个线程就是创建一个Thread类的实例。每一个线程都有要执行任务，线程的任务处理逻辑可以在Thread类的run实例方法中直接实现或者通过该方法进行调用, 因此run方法相当于线程的任务处理逻辑入口方法。它是由java虚拟机在运行相应线程时直接调用，而不是由应用代码进行调用。

​    运行一个线程实际上就是让java虚拟机执行该线程的run方法，从而使相应线程的任务处理逻辑代码得以执行。为此，我们首先要启动线程。Thread类 的start方法的作用就是启动相应的线程。启动一个线程实质就是请求java虚拟机运行相应的线程，而这个线程具体何时能够运行是由线程调度器决定的。因此，start方法调用结束并不意味着相应的线程已经开始运行，这个线程可能稍后才被运行，也可能永远都不会被运行。

  创建线程的方式一般有两种，一种是继承Thread类， 一种是实现Runnable接口。继承Thead类 后在子类中覆盖run方法并在该方法中实现线程任务处理逻辑；使用实现接口Runnable方法来实现，并在该实例的run方法中实现任务处理逻辑。

注意：线程属于“一次性用品”，我们不能通过重新调用一个已经运行结束的线程start方法使其重新运行。事实上，start方法也只能够被运行一次，多次调用同一个Thread实例的start方法会导致其抛出IllegalThreadStateException异常。 

#### 4、``Thread类中常用方法``

 4.1 Thread.currentThread()可以返回当前线程。

 由于同一段代码可能被不同的线程执行，因此当前线程是相对的。即 Thread.currentThread()的返回值在代码实际运行的时候可能对应着不同的线程(对象)

#####  4.2、join方法

join方法 的作用是 让一个线程先执行后，其他的线程在执行。让相应的线程想暂停下，等另外一个线程运行结束后才开始继续执行。

#####  4.3、yield 静态方法

  yield 静态方法的作用相当于执行该方法的线程对线程调度器说，我们现在不急，如果别的人需要处理器资源那么先给它用吧。当然，如果没有其他人要用，我也不介意继续占用。

#####  4.4、sleep静态方法

   sleep静态方法的作用相当于执行该方法的线程对线程调度器说，我想小憩一会儿，过段时间在叫醒我 继续干活。

#### 5、``线程的声明周期状态``

 5.1 线程的声明周期状态有 ，NEW, RUNABLE, BLOCKED, WAITING, TIMED_WAITING, TERMINATED

 $\textcolor{Red}{NEW}$   ：表示一个已经创建而未启动的线程处于该状态，由于一个线程实例只能够被启动一次，因此一个线程只可能有一次处于该状态。

 $\textcolor{Red}{RUNNABLE}$ : 可以看成一个复合状态，它包含两个子状态 <font color=#FF0000 >READE  </font>和 <font color=#0000FF >RUNNING </font>。前者表示处于该状态的线程可以被线程调度器进行调度从而使之处于RUNNING状态。后者表示处于该状态的线程处于正在运行，即相应线程对象的run方法所对应的指令正处由处理器执行。 处于READ子状态的线程也被称为活跃线程。

$\textcolor{Red}{BLOCKED}$   : 一个线程发起阻塞式I/O操作后，或者申请一个由其他线程持有的独占资源(比如锁)时，相应的线程会处于该状态。处于BLOCKED状态的线程并不会占用处理器资源，因为这些资源 已经让其他线程去使用了。当阻塞式I/O操作完成后，或者线程获得了其申请的资源，该线程的状态又可以转换为RUNNABLE。

 $\textcolor{Red}{WAITING}$    : 一个线程 执行了某些特定的方法之后就会处于这种等待其他线程执行另外一些特定操作的状态，能够使执行线程变更为WAITING 状态的方法包括：Object.wait(), Thread.join(), LockSupport.park(Object)。能够使相应线程从WAITING变更为RUNNABLE的相应方法包括：Object.notify()/notifyAll()和LockSupport.unpark(Object)

  $\textcolor{Red}{TIMED  WAITING}$  : 该状态和WAITING类似，差别在于处于该状态的线程并非无限制地等待其他线程执行特定操作，而是处于带有时间现在的等待状态。当其他线程没有在指定时间内执行该线程所期望的特定操作，该线程的状态自动状态转换为RUNNABLE.

   $\textcolor{Red}{TERMINATED}$    : 已经执行结束 的线程处于该状态。由于一个线程实例只能够被启动一次，因此一个线程也只能有一次处于该状态。Thread.run正常返回或者由于抛出异常而提前终止都会导致相应线程处于该状态。



#### 6、``串行、并发与并行``

 串行：比如安装电脑，我们需要报cpu, 显卡这些安装之后，其他事情才能执行。

 并发：这种方式也可以投入一个人。这个人先开始做事情A,事情A的准备活动做好后，在等待事情A完成的这段时间内 开始做事情B,  再等待事情B完成的这段时间内开始做事情C。这个整个过程实际上是已交替的方法利用等待某件事情完成的时间来完成其他事情。

 并行：并行这种方式需要投入人数要多些，每个人负责完成其中一件事情。 

 并发就是在一段时间以交替的方式去完成多个任务，而并行就是以齐头并进的方式去完成多个任务。并发与并行还是存在一些差异。首先，现实世界中的一个人可以以并发的方式去完成几件事情，而软件要以并发的方式去完成几个任务往往需要借助多个线程。



#### 7、``竞态``

多线程编程中  进程会遇到一个问题，就是有的时候对同样的输入 ，程序的输入有时候是正确的而有的时候不正确，这种计算结果的正确性与时间有关的现象就称为竞态。

竞态不一定就是导致计算结果的不确定，它只是不排除计算结果时而正确时而错误的可能。

竞态往往伴随着读取脏数据的问题 ，即一个线程读取到一个过时的数据，丢失更新问题。



#### 8、``线程安全性``

一般而言，如果一个类在单线程环境下能够正常运行，并且在多线程环境下，在其使用方不做任何的改变的情况下 也能运作正常，那么我们就称之为 线程安全的，相应的我们称这个类具有线程安全性。



#### 9、``原子性``

什么是原子性呢？ 原子性表示的意思是不可分割的。对于涉及共享变量访问的操作，若改操作从其执行线程以外的任意线程来看是不可分割的，那么该操作就是原子操作，相应的我们称该操作具有原子性。

  原子性的不可分割 指其访问某个共享变量的操作从其执行线程以外的任何线程来看，该操作要么已经执行结束要么未发生，即其他线程不会 看到 该操作执行了部分的中间效果。

   比如：去ATM去取钱，我们取钱这个操作 要么成功要么失败，成功了我们取到钱了，失败我们没有取到钱。不会出现我们没有取得钱 而银行账户里面的钱少了这种 ，除非ATM出现了问题。

 $\textcolor{Red}{**原子性 就是保证数据完整性和准确性**}。$

在java中有两种方式来实现原子性， $\textcolor{Magenta}{一种是使用Lock(锁)} $，锁具有排他性，即它能够保障一个共享变量在任意一个时刻只能被一个线程访问。这样就排除了多个线程在同一时刻访问共享变量而导致干扰和冲突的可能。

另一种是利用$\textcolor{Magenta}{处理器提供的专门CAS(Compare-and-Swap)指令}$,CAS指令实现原子性的方式与锁实现原子性的方式是相同的，其差别就是在锁通常是在软件这一层实现的，而CAS则是直接在硬件这一层实现的。

#### 10、``可见性``

在多线程环境下， 一个线程对共享变量进行更新后，后续访问该变量的线程可能无法立即读取到这个更新的结果，甚至永远也无法读取到这个更新的结果，这就是线程安全问题的另外一个表现形式 可见性

  如果一个线程对共享变量进行更新后，后续访问该变量的线程可以读取到该更新的结果，那么我们就称这个线程对共享变量的更新对其他线程可见，否则我们就称这个线程对共享变量的更新对其他线程不可见。

   多线程程序在可见性方面存在问题意味着某些线程读取了旧数据，而这可能导致程序出现我们所不期望的结果。

   可见性与计算机的存储系统有关，程序的变量可能被分配到寄存器而不是主内存中进行存储。每个处理器都有其寄存器，而一个处理器无法读取到另外一个处理器上寄存器的内容。

   处理器对主内存的访问不是直接访问的，而是通过高速缓存子系统进行的。一个处理器的高速缓存中的内容不能被另外一个处理器直接读取，但是一个处理器可以通过缓存一致性协议（Cache Conherence Protocol）来读取其他处理器高速缓存中的数据，并将读取的到的数据更新到高速缓存中。

#### 11、``有序性``