

## 时间复杂度计算

1、示例

```c
int func1(void){
  printf("hhh\n");  //执行1次
  return 0; //执行1次
}
//调用1次函数func1，内部一共执行2次语句
```

方法2

```c
int func2(int n){
  //当n=2时，i=0执行1次， i<n 执行共3次， ++1执行2次
   // i=2是 ，这时 判断才不成立 所以 i<n 执行了3次
  for(int i=0;i<n; ++i){
     printf("sfe\n");  //执行2次
  }
  return 0; //执行1次
}
// 在调用func2方法 当n=2时，一共执行了9次
```

根据上面的假设for循环的第一部分 i=0 ，无论n多 都只执行1次，for循环的第三部分 ++i和循环体 执行次数都是1。而for循环体中 判断条件 i<n ,在判断n次成立情况后，还需要判断1次不成立的情况，所以最终执行次数是n+1次， return返回条件执行1次。 所以总的执行次数就是 3n+3次 。

一段代码的总执行次数用T(n)表示 ，T(n)=3n+3

```
调用1次函数func1,T(n) = 2。  调用1次函数func2 , T(n)=3n+3
T表示: 当输入为n时，某段代码的总执行次数
n表示：输入数据的大小或者数量
```

在衡量代码的执行速度的依据，当代码比较多的时候，就比较麻烦了，还要一条条语句的去数，而且函数在调用函数的时候，运算起来也很麻烦。所以算法一般 用T(n)简化的估算值，来衡量代码的执行的速度。这个简化的估算值叫做$\textcolor{red}{时间复杂度}$。

```
调用1次函数func1,T(n)=2 ，时间复杂度就是1，也就O(n)
调用1次函数func2,T(n)=3n+n ,时间复杂度是 n, 所以O(n)

T(n)= 常数*n + 常数，
       1       2
 当n越来越大，前面的1整体部分就越来越大，第2部分保持不变，也就导致了第2部分相当于第1部分不存在，所以我们可以省略后的常数。而第一部分的常数可以估算为1或者理解为去掉这个作为系数的常数。所以它的时间复杂度就是n。
```

对于多项式 ，我们只需要保留n的最高次数项。

比如 T(n) =5n^3 + 666n^2 +33 ,这个就保留 最高次数项 5n^3， 那么这个的时间复杂度就是n的3次方。也就是O(n^3)。



这里小总结下

```
T(n)是不是常数：
 1、是，时间复杂度为O(1)
 2、否：时间复杂度为O(保留T(n)的最高次项并且去掉最高次项的系数)
```































